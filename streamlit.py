import streamlit as st
import os
import shutil
import glob
import tempfile
import stat
from git import Repo
import openai
from datetime import datetime

# === CONFIGURATION ===
SOURCE_EXTENSIONS = [".cs", ".vb", ".fs", ".csx", ".vbx"]

# Backend configuration - Store your API keys here
#
#


def handle_remove_readonly(func, path, exc_info):
    """Fix for Windows permission error when deleting .git objects."""
    os.chmod(path, stat.S_IWRITE)
    func(path)

def clone_repository(repo_url, clone_to):
    """Clone a GitHub repository to local directory"""
    if os.path.exists(clone_to):
        shutil.rmtree(clone_to, onerror=handle_remove_readonly)
    Repo.clone_from(repo_url, clone_to)

def find_source_files(base_path, extensions):
    """Find all source code files with specified extensions"""
    source_files = []
    for ext in extensions:
        source_files.extend(glob.glob(f"{base_path}/**/*{ext}", recursive=True))
    return source_files

def scrape_files(file_paths):
    """Read and combine content from all source files"""
    content = ""
    for path in file_paths:
        try:
            with open(path, 'r', encoding='utf-8', errors='ignore') as f:
                content += f"\n\n--- File: {os.path.relpath(path)} ---\n\n"
                content += f.read()
        except Exception as e:
            st.warning(f"Error reading {path}: {e}")
    return content

def call_agent_to_generate_readme(scraped_code):
    """Use OpenAI to generate README.md content"""
    client = openai.OpenAI(api_key="")
    
    prompt = (
        "You are an expert software engineer. Generate a clean and professional `README.md` for this .NET project based on the source code below.\n"
        "Include the following sections:\n"
        "- Project Title\n- Description\n- Features\n- Installation\n- Usage\n"
        "- Technologies Used\n- Contributing\n- License\n\n"
        "Here is the source code:\n\n"
        f"{scraped_code[:12000]}"  # Keep it safe for tokens
    )

    response = client.chat.completions.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": "You are a helpful assistant that writes technical documentation."},
            {"role": "user", "content": prompt}
        ],
        temperature=0.3,
    )

    return response.choices[0].message.content

def push_readme_to_github(repo_dir, github_url, branch="main", token=None):
    """Push the generated README.md back to GitHub"""
    repo = Repo(repo_dir)
    repo.git.add("README.md")
    repo.index.commit("chore: add autogenerated README.md")

    if token:
        # Inject token into remote URL
        github_url_with_token = github_url.replace("https://", f"https://{token}@")
        origin = repo.remote("origin")
        origin.set_url(github_url_with_token)

    repo.git.push("origin", branch)

def main():
    st.set_page_config(
        page_title="README Generator",
        page_icon="üìù",
        layout="wide"
    )

        # Display logo on the top-left
    logo_path = "logo.png"  # Your logo file should be in the same directory
    if os.path.exists(logo_path):
        st.sidebar.image(logo_path, use_container_width=True)


    st.title("Automated README Generator")

    # Sidebar for configuration
    with st.sidebar:
        st.header("‚öôÔ∏è Configuration")
        
        # Branch selection
        branch = st.selectbox(
            "Target Branch",
            ["main", "master", "develop"],
            help="Select the branch to push README to"
        )
        
        # API Status indicators
        st.markdown("---")
        st.subheader(" Backend Status")
        
        if OPENAI_API_KEY:
            st.success("OpenAI API Key configured")
        else:
            st.error("‚ùå OpenAI API Key not configured")
            
        if GITHUB_TOKEN:
            st.success("GitHub Token configured")
        else:
            st.warning("‚ö†Ô∏è GitHub Token not configured (README won't be pushed)")

    # Main interface
    col1, col2 = st.columns([1, 1])

    with col1:
        st.header(" Repository Input")
        
        # GitHub URL input
        github_url = st.text_input(
            "GitHub Repository URL",
            placeholder="https://github.com/username/repository",
            help="Enter the full GitHub repository URL"
        )
        
        # Validate URL
        if github_url and not github_url.startswith("https://github.com/"):
            st.error("Please enter a valid GitHub repository URL")
            return

        # Generate button
        generate_button = st.button(
            " Generate README",
            type="primary",
            disabled=not (github_url and OPENAI_API_KEY)
        )

        if not OPENAI_API_KEY:
            st.error("‚ùå OpenAI API key not configured in backend")
        elif not github_url:
            st.info("Please enter a GitHub repository URL")

    with col2:
        st.header("üìä Process Status")
        status_container = st.container()

    # Main processing logic
    if generate_button:
        with status_container:
            progress_bar = st.progress(0)
            status_text = st.empty()
            
            try:
                # Step 1: Clone repository
                status_text.text("üîÑ Cloning repository...")
                progress_bar.progress(20)
                
                with tempfile.TemporaryDirectory() as temp_dir:
                    clone_dir = os.path.join(temp_dir, "cloned_repo")
                    clone_repository(github_url, clone_dir)
                    
                    # Step 2: Find source files
                    status_text.text("üîç Finding source files...")
                    progress_bar.progress(40)
                    
                    source_files = find_source_files(clone_dir, SOURCE_EXTENSIONS)
                    
                    if not source_files:
                        st.error("‚ùå No .NET source files found in the repository")
                        return
                    
                    st.success(f"‚úÖ Found {len(source_files)} source files")
                    
                    # Step 3: Scrape file contents
                    status_text.text("üìñ Reading source code...")
                    progress_bar.progress(60)
                    
                    scraped_code = scrape_files(source_files)
                    
                    # Step 4: Generate README
                    status_text.text("ü§ñ Generating README with AI...")
                    progress_bar.progress(80)
                    
                    readme_content = call_agent_to_generate_readme(scraped_code)
                    
                    # Step 5: Optional GitHub push
                    if GITHUB_TOKEN:
                        status_text.text("‚¨ÜÔ∏è Pushing to GitHub...")
                        progress_bar.progress(90)
                        
                        readme_path = os.path.join(clone_dir, "README.md")
                        with open(readme_path, 'w', encoding='utf-8') as f:
                            f.write(readme_content)
                        
                        try:
                            push_readme_to_github(clone_dir, github_url, branch, GITHUB_TOKEN)
                            st.success("‚úÖ README pushed to GitHub successfully!")
                        except Exception as e:
                            st.warning(f"‚ö†Ô∏è Generated README but failed to push to GitHub: {e}")
                    else:
                        st.info("‚ÑπÔ∏è GitHub token not configured - README not pushed to repository")
                    
                    # Complete
                    status_text.text("‚úÖ README generation completed!")
                    progress_bar.progress(100)
                    
                    # Display results
                    st.header("üìÑ Generated README.md")
                    
                    # Download button
                    st.download_button(
                        label="‚¨áÔ∏è Download README.md",
                        data=readme_content,
                        file_name="README.md",
                        mime="text/markdown"
                    )
                    
                    # Display content
                    with st.expander("üìñ View README Content", expanded=True):
                        st.markdown(readme_content)
                    
                    # File information
                    with st.expander("üìÅ Source Files Analyzed"):
                        for file_path in source_files:
                            st.text(f"‚Ä¢ {os.path.relpath(file_path, clone_dir)}")
                    
            except Exception as e:
                st.error(f"‚ùå An error occurred: {str(e)}")
                st.exception(e)

    # Footer
    st.markdown("---")
    

if __name__ == "__main__":
    main()